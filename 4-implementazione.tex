\section{Implementazione}
In seguito all'analisi e alla formulazione del modello relativo al problema, si è sviluppato uno strumento software basato su un solver per verificare la validità dei concetti prima esposti. Lo strumento software è stato sviluppato in Java e come solver è stato utilizzato Gurobi. In questa sezione si presenterà suddetto strumento e si esporranno le strutture dati utilizzate.
\subsection{Gurobi}
Gurobi Optimizer è un solver commerciale sviluppato da Gurobi Optimization, LLC. Il nome viene dagli autori Dr. Zonghao Gu, Dr. Edward Rothberg e Dr. Robert Bixby, che fondarono Gurobi nel 2008. Gurobi viene utilizzato per problemi di programmazione lineare, programmazione quadratica, programmazione a vincoli quadratici, programmazione lineare mista intera, programmazione quadratica mista intera e programmazione a vincoli quadratici mista intera. Ad oggi, Gurobi viene utilizzato da più di 40 industrie ed è uno dei solver più utilizzati dalle aziende big tech\cite{GUROBIPAGE}.
\subsection{Strutture dati, rappresentazione dell'istanza e dati tecnici}
Si è diviso il progetto in due pacchetti:
\begin{itemize}
	\item model: contiene le classi relative al modello e ai suoi vincoli, assieme ad una classe di util per la configurazione e la classe Main.
	\item data: contiene le classi e le informazioni utili a organizzare i dati necessari per il modello.
\end{itemize}
All'interno di data, è presente una raccolta di istanze divise in BAx.txt e EXx.txt, in base al tipo di problema che si vuole risolvere (base o esteso). Questi file contengono i dati relativi al fabbisogno e ai lavoratori, dei quali si salvano alcuni dati anagrafici, la tipologia contrattuale e le skill che possiede nel caso degli EXx.txt. La classe Worker serve per salvare i dati relativi al cassiere, di cui:
\begin{itemize}
	\item EmploymentType: un enum che contiene le informazioni relative alla tipologia contrattuale, come monte ore settimanale previsto, ore settimanali massime assegnabili e numero massimo di turni giornalieri.
	\item id: un long che rappresenta univocamente il cassiere.
\end{itemize}
Le skill vengono salvate mediante un enum chiamato, sorprendentemente, Skill. La classe Instance si occupa della preparazione dei dati necessari per il modello, come i turni e l'insieme dei lavoratori. All'interno di Instance, viene anche pregenerato l'insieme I11, che contiene le coppie di turni. Le strutture dati principali utilizzate sono:
\begin{itemize}
	\item List: per salvare i turni.
	\item Set: per salvare i lavoratori, separati per tipologia contrattuale.
	\item Map: per  collegare tra loro diversi dati, come il turno agli slot che copre.
\end{itemize}
Per il trasferimento di dati, rispetto a turni o anche successivamente ai lavoratori rispetto ai turni, si utilizzano i Record. I dati vengono letti mediante parsing dai file di testo (questo più avanti verrà ripreso come possibile punto di estensione, introducendo file .json o .xml).

Si passa ora al pacchetto model, il quale è separato nelle seguente classi:
\begin{itemize}
	\item Config: una classe di configurazione, contiene costanti utili per impostare il problema;
	\item Main: esegue il loop di ottimizzazione sulle istanze generate e richiama i metodi necessari per stampare i risultati;
	\item PersonnelSchedulingBaseModel e ExtendedModel: il cuore dell'intero progetto, in quanto contengono tutti i vincoli relativi al modello;
	\item SolutionPrinter: stampa le soluzioni su un file di .csv. estendere questo?
\end{itemize}
All'interno di PersonnelSchedulingBaseModel, tramite la programmazione lineare si rappresentano i vincoli; si riporta un esempio di codice che rimanda ai vincoli di massimo numero di turni assegnabili per giorno:
\begin{lstlisting}[caption={Esempio di metodo per i vincoli}, style=java, label={lst:esempio_java}]
public void maxTurnsPerDay() throws GRBException {
	for (Worker w : instance.getAllWorkers()) {
		for (int day = 1; day <= Instance.TIMEWINDOW; day++) {
			
			int maxT = w.getType().maxTurns(day);   
			GRBLinExpr lhs = new GRBLinExpr();
			
			for (Shift s : instance.getDayByShifts(day)) {
				GRBVar xcs = x_CS_Var.get(new WorkerShift(w.getId(), s.id()));
				if (xcs != null) lhs.addTerm(1.0, xcs);
			}
			
			model.addConstr(lhs, GRB.LESS_EQUAL, maxT,
			"MaxTurns_w" + w.getId() + "_d" + day);
		}
	}
}
\end{lstlisting}
Le strutture dati utilizzate sono le stesse utilizzate per Instance, con la differenza che in queste due classi le Map assumono un ruolo più fondamentale, in quanto stanno alla base dell'intera costruzione del modello collegando le variabili di Gurobi ai relativi dati. Le Map utilizzate sono le seguenti:
\begin{lstlisting}[caption={Map usate per le variabili del modello}, style=java, label={lst:structureMap}]
private final Map<DaySlot, GRBVar> u_DK = new HashMap<>();
private final Map<WorkerShift, GRBVar> x_CS_Var = new HashMap<>();
private final Map<WorkerDay, GRBVar> splitC_D = new HashMap<>();
private final Map<WorkerDay, GRBVar> staccoC_D = new HashMap<>(); 
private final Map<WorkerDay, GRBVar> riposoC_D = new HashMap<>();
\end{lstlisting}
\textit{DaySlot}, \textit{WorkerShift} e \textit{WorkerDay} sono dei Record. Si utilizzano le seguenti classi di Gurobi per implementare il modello:
\begin{itemize}
	\item GRBEnv: l'environment per Gurobi, fondamentale per impostare tutto.
	\item GRBModel: l'oggetto che rappresenta il modello per Gurobi. I metodi utilizzati per questa classe sono: addVar e addConstr per aggiungere variabili e vincoli, setObjective per impostare l'obiettivo, optimize per ottimizzarlo.
	\item GRBVar: le variabili del modello per Gurobi, aggiunte mediante addVar al modello.
	\item GRBLinExpr: un'espressione lineare, importante per la definizione dei vincoli.
\end{itemize}
Le funzioni obiettivo sono salvate mediante GRBLinExpr. Per la funzione obiettivo si sono trovate due strade:
\begin{itemize}
	\item Metodo pesato: come espresso nella sezione 3, si sommano tutti gli obiettivi assegnandogli i specifici pesi e si esegue poi l'ottimizzazione del modello.
	\item Metodo gerarchico: si dà una priorità agli obiettivi, si ottimizza prima rispetto all'obiettivo con priorità più alta, si passa poi a quelli con priorità più bassa aggiungendo un vincolo che garantisca il non peggioramento dell'obiettivo precedente. 
\end{itemize}
In Gurobi, per entrambi gli approcci si può adoperare il seguente metodo:
\begin{lstlisting}[style=java, label={lst:setObjective}]
void setObjectiveN(GRBLinExpr expr, int index, int priority, double weight, double abstol, double reltol, String name)
\end{lstlisting}
ove:
\begin{itemize}
	\item expr: obiettivo.
	\item index: indice dell'obiettivo, utile per il log.
	\item priority: priorità all'interno della gerarchia di ottimizzazione.
	\item weight: peso assegnato all'obiettivo.
	\item abstol: tolleranza assoluta per l'obiettivo, ovvero di quanto può degradare la soluzione quando si ottimizzano obiettivi secondari (stessa unità dell'obiettivo).
	\item reltol: tolleranza relativa per l'obiettivo, come abstol ma relativo (percentuale dell'obiettivo).
	\item name: nome dell'obiettivo, utile per il log.
\end{itemize}
Per esprimere correttamente quanto esposto nella sezione 3, il metodo è stato usato con la priorità imposta uguale per tutti gli obiettivi, tuttavia si potrebbe comunque risolvere il problema dando priorità maggiore alla copertura e a eventuali obiettivi di equità e minimizzazione delle ore, così da garantire una soluzione migliore per gli obiettivi principali.

Si introduce infine la classe SolutionPrinter. Questa classe contiene metodi utili alla stampa della soluzione trovata da Gurobi, in particolare risultano fondamentali:
\begin{itemize}
	\item writeSolutionCsvTablesByWorker: salva su un file .csv gli orari separati per singolo cassiere.
	\item exportUtoCsv: salva su un file .csv una tabella contenente i valori di $u(d,k)$ per ogni slot temporale, mostrando come si comporta Gurobi.
	\item writeObjectiveResult: ritorna un file .txt con i valori trovati per singolo obiettivo.
\end{itemize}
Si riporta un esempio di tabella oraria generata da writeSolutionCsvTablesByWorker:
\begin{center}
	\includegraphics[width=75mm]{figures/esempioorario.png}
\end{center}
\pagebreak
\subsection{Risultati implementativi}
In quanto disponibili, gli esperimenti sono stati eseguiti su una macchina con le seguenti specifiche tecniche:
\begin{itemize}
	\item AMD Ryzen™ 7 5700X CPU @ 3.40GHz × 16.
	\item 32GB RAM 3200MHz.
\end{itemize}
I test sono stati eseguiti su 3 istanze per il modello base e 3 istanze per il modello esteso, dando 3 diversi limiti di tempo (5, 10 e 30 minuti). I valori dei pesi sono riportati nell'appendice, mentre per i relativi significati dietro i valori dei singoli obiettivo si rimanda alla sezione 3.

Le versioni di Java e Gurobi utilizzate sono rispettivamente Java-21 e Gurobi 13.0.0.
\begin{center}
	\begin{tabular}{ c c c c }
		BA1 & & Valore ottimo & 1185.5\\
		\hline
		Tempo limite & 300 & 600 & 1800\\
		\hline
		Valore f.o & 3171.5 & 2985.0 & 1271.5\\
		Gap(\%) & 62.6 & 60.3 & 6.76\\
		\hline
		$f_1$ & 1980.0 & 1800.0 & 40.0\\
		$f_2$ & 1098.5 & 1110.0 & 1150.5\\
		$f_3$ & 93.0 & 75.0 & 81.0\\
		\hline
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{ c c c c }
		BA2 & & Valore ottimo & 8608.0\\
		\hline
		Tempo limite & 300 & 600 & 1800\\
		\hline
		Valore f.o & 8624.0 & 8624.0 & 8624.0\\
		Gap(\%) & 0.19 & 0.19 & 0.19\\
		\hline
		$f_1$ & 8080.0 & 8080.0 & 8080.0\\
		$f_2$ & 516.0 & 516.0 & 516.0\\
		$f_3$ & 28.0 & 28.0 & 28.0\\
		\hline
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{ c c c c }
		BA3 & & Valore ottimo & 5206.0\\
		\hline
		Tempo limite & 300 & 600 & 1800\\
		\hline
		Valore f.o & 5242.0 & 5240.0 & 5235.0\\
		Gap(\%) & 0.69 & 0.65 & 0.55\\
		\hline
		$f_1$ & 4340.0 & 4340.0 & 4340.0\\
		$f_2$ & 846.0 & 846.0 & 846.0\\
		$f_3$ & 56.0 & 54.0 & 49.0\\
		\hline
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{ c c c c }
		EX1 & & Valore ottimo & 473.0\\
		\hline
		Tempo limite & 300 & 600 & 1800\\
		\hline
		Valore f.o & 474.0 & 473.5 & 473.5 \\
		Gap(\%) & 0.21 & 0.11 & 0.11\\
		\hline
		$f_1$ & 0.0 & 0.0 & 0.0\\
		$f_2$ & 336.0 & 336.0 & 336.0\\
		$f_3$ & 24.0 & 24.0 & 24.0\\
		$f_4$ & 0.0 & 0.0 & 0.0\\
		$f_5$ & 0.0 & 0.0 & 0.0\\
		$f_6$ & 0.0 & 0.0 & 0.0\\
		$f_7$ & -2.0 & -2.0 & -2.0\\
		$f_8$ & 0.0 & 0.0 & 0.0\\
		$f_9$ & 116.0 & 115.5 & 115.5\\
		\hline
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{ c c c c }
		EX2 & & Valore ottimo & 10271.0\\
		\hline
		Tempo limite & 300 & 600 & 1800\\
		\hline
		Valore f.o & 10272.5 & 10272.5 & 10272.5\\
		Gap(\%) & 0.01 & 0.01 & 0.01\\
		\hline
		$f_1$ & 8220.0 & 8220.0 & 8220.0\\
		$f_2$ & 516.0 & 516.0 & 516.0\\
		$f_3$ & 36.0 & 36.0 & 36.0\\
		$f_4$ & 92.0 & 92.0 & 92.0\\
		$f_5$ & 0.0 & 0.0 & 0.0\\
		$f_6$ & 180.0 & 180.0 & 180.0\\
		$f_7$ & -4.5 & -4.5 & -4.5\\
		$f_8$ & 0.0 & 0.0 & 0.0\\
		$f_9$ & 1233.0 & 1233.0 & 1233.0\\
		\hline
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{ c c c c } 
		EX3 & & Valore ottimo & 1419.3\\
		\hline
		Tempo limite & 300 & 600 & 1800\\
		\hline
		Valore f.o & 1819.7 & 1693.9 & 1669.3\\
		Gap(\%) & 22.0 & 16.2 & 15.0\\
		\hline
		$f_1$ & 120.0 & 0.0 & 0.0\\
		$f_2$ & 1181.0 & 1194.5 & 1187.5\\
		$f_3$ & 218.0 & 208.0 & 205.0\\
		$f_4$ & 89.0 & 102.5 & 95.5\\
		$f_5$ & 21.2 & 14.4 & 10.8\\
		$f_6$ & 143.0 & 135.0 & 138.0\\
		$f_7$ & -5.5 & -5.5 & -5.5\\
		$f_8$ & 0.0 & 0.0 & 0.0\\
		$f_9$ & 53.0& 45.0 & 38.0\\
		\hline
	\end{tabular}
\end{center}
